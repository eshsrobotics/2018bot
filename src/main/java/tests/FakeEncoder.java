package tests;

import java.util.Random;

import models.Constants;
import models.EncoderInterface;
import models.Point;

/**
 * A fake encoder class.  Like real encoders, it tracks the distance it
 * travels; unlike real encoders, it must periodically be updated with its new
 * position, and it has options for deliberately misreporting its distance (to
 * simulate cumulative inaccuracies.)
 *
 * @author uakotaobi
 */
public class FakeEncoder implements EncoderInterface {

    private Point actualPosition;
    private Point lastPosition;
    private double actualDistanceTraveled;
    private double maxDeviancePerFoot;

    /**
     * Initializes this encoder by setting its initial position
     * to the origin.
     *
     * The fake encoder is designed to simulate the natural inaccuracy we
     * expect to encounter during autonomous mode due to wheel slippage.  You can
     * use the arguments to control this level of inaccuracy.
     *
     * @param initialPosition     The initial position of the virtual robot's
     *                            center of mass, in feet.
     * @param maxDeviancePerFoot  The maximum variance from the true,
     *                            traveled distance that the encoder is allowed
     *                            to report per foot of distance traveled.  The
     *                            deviance is generated by seeding the random
     *                            number generator, so it will be consistent
     *                            for any given traveled distance.
     *
     *                            Note that this deviance cares only about
     *                            total distance traveled, not distance from the
     *                            initial position.  Driving in circles will
     *                            slowly increase the deviance even if you're
     *                            not actually going anywhere.
     */
    public FakeEncoder(Point initialPosition, double maxDeviancePerFoot) {
        actualPosition = initialPosition;
        this.maxDeviancePerFoot = maxDeviancePerFoot;
        reset();
    }

    /**
     * The fake encoder isn't actually smart enough to track distance traveled
     * on its own.  It needs your data.
     *
     * @param newPosition The new virtual position of the robot, in feet.
     */
    public void updatePosition(Point newPosition) {
        actualDistanceTraveled += actualPosition.dist(newPosition);
        actualPosition = newPosition;
    }

    /* (non-Javadoc)
     * @see models.EncoderInterface#reset()
     */
    @Override
    public void reset() {
        lastPosition = actualPosition;
        actualDistanceTraveled = 0;
    }

    /* (non-Javadoc)
     * @see models.EncoderInterface#getDistance()
     */
    @Override
    public double getDistance() {

        // This is very unlikely to overflow, and it will remain consistent for
        // distances that are less than Constants.EPSILON feet apart.
        long distanceTraveledAsLong = (long)(actualDistanceTraveled / Constants.EPSILON);

        Random generator = new Random(distanceTraveledAsLong);
        double drift = generator.nextDouble() * actualDistanceTraveled * this.maxDeviancePerFoot;
        return actualDistanceTraveled + drift;
    }

}
