package tests;

import java.util.Random;

import edu.wpi.first.wpilibj.interfaces.Gyro;
import models.Constants;

/**
 * A gyro that looks somewhat like the real edu.wpi.first.wpilibj.AnalogGyro
 * from a programming point of view.  However, it returns doctored data with an
 * option to control how corrupted it gets over time.
 *
 * @author uakotaobi
 *
 */
public class FakeGyro implements Gyro {

    /**
     * The fake gyro's current true angle, in degrees.
     */
    private double currentAngle;

    /**
     * The number of degrees that the fake gyro has been asked to
     * "rotate" since the last call to reset().
     */
    private double totalDegreesRotated;

    /**
     * The number of degrees of drift that we will incorporate into our
     * getAngle() measurements, as a function of totalDegreesRotated.  For
     * example, if this is 0.0025 and you call:
     *
     *   reset()
     *   updateAngle(200)
     *   updateAngle(-50)
     *
     * Then we've rotated a total of |0 - 200| + |200 - -50| = 450 degrees, and
     * the total drift _at this point_ is a random number in the interval
     * [0, 450 * 0.025) -- that is, Math.random() * 1.125.
     *
     * Does this model cumulative gyro errors well?  Probably not.  But it may
     * suffice for programming autonomous to account for drift.
     */
    private double maxDeviancePerDegree;

    /**
     * We need to know how long it's been since the last call to reset() in
     * order to get an accurate turning rate (which we then fuzz again
     * deliberately using random drift.)
     *
     * The constructor also calls reset().
     */
    private long lastResetTimeMilliseconds;

    /**
     * Initializes this fake gyro object with the given initial angle.
     *
     * @param initialAngle The angle that the getAngle() method will report
     *                     having right after this call.
     *
     * @param maxDeviancePerDegree The maximum variance from the true,
     *                             rotation that the Fakeyro is allowed to
     *                             report per degree of experienced rotation.
     *                             The deviance is generated by seeding the
     *                             random number generator, so it will be
     *                             consistent for any given cumulative
     *                             rotation.
     *
     *                             Note that this deviance cares only about
     *                             total degrees rotated, not deviation from
     *                             the initial angle.  Oscillating back and
     *                             forth a few degrees will slowly increase the
     *                             deviance even if the gyro never deviates
     *                             strongly from the initial angle.
     *
     */
    public FakeGyro(double initialAngle, double maxDeviancePerDegree) {
        currentAngle = initialAngle;
        reset();
    }

    /**
     * This is nothing like a real gyro, so something must continuously report
     * the true simulated angle to it in order for it to remember that and then
     * pretend that it can't measure it accurately during getAngle().
     *
     * @param newAngle The true current heading of your fake robot.
     */
    public void updateAngle(double newAngle) {
        totalDegreesRotated += Math.abs(currentAngle - newAngle);
        currentAngle = newAngle;
    }

    /* (non-Javadoc)
     * @see edu.wpi.first.wpilibj.interfaces.Gyro#calibrate()
     */
    @Override
    public void calibrate() { }

    /* (non-Javadoc)
     * @see edu.wpi.first.wpilibj.interfaces.Gyro#free()
     */
    @Override
    public void free() { }

    /* (non-Javadoc)
     * @see edu.wpi.first.wpilibj.interfaces.Gyro#getAngle()
     */
    @Override
    public double getAngle() {

        // This is very unlikely to overflow, and it will remain consistent for
        // angles that are less than Constants.EPSILON feet apart.
        long totalDegreesRotatedAsLong = (long)(totalDegreesRotated / Constants.EPSILON);

        Random generator = new Random(totalDegreesRotatedAsLong);
        double drift = generator.nextDouble() * totalDegreesRotated * this.maxDeviancePerDegree;
        return currentAngle + drift;
    }

    /* (non-Javadoc)
     * @see edu.wpi.first.wpilibj.interfaces.Gyro#getRate()
     */
    @Override
    public double getRate() {
        // This is an average turning rate since the last call to reset(), and
        // is hopefully a bit more accurate than an instantaneous turning rate.
        //
        // However, it is still subject to drift!
        double deltaSeconds = (System.currentTimeMillis() - lastResetTimeMilliseconds) / 1000;
        double drift = getAngle() - currentAngle;
        return (totalDegreesRotated + drift) / deltaSeconds;
    }

    /* (non-Javadoc)
     * @see edu.wpi.first.wpilibj.interfaces.Gyro#reset()
     */
    @Override
    public void reset() {
        currentAngle = 0;
        totalDegreesRotated = 0;
        lastResetTimeMilliseconds = System.currentTimeMillis();
    }

}
